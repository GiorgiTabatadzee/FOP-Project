import java.util.Map;
import java.util.Stack;


    import java.util.HashMap;
import java.util.Map;
import java.util.Stack;

    public class KotlinToJavaInterpreter {

        private final Map<String, Integer> variables = new HashMap<>();
        private final Map<String, Boolean> booleanVariables = new HashMap<>();
        private final Stack<Boolean> executionStack = new Stack<>(); // Stack to track block execution state
        private boolean breakFlag = false; // Flag to indicate if a break statement has been encountered

        public void interpret(String code) {
            String[] lines = code.split("\n");
            int lineIndex = 0;  // To track the current line index in the code

            while (lineIndex < lines.length) {
                String line = lines[lineIndex].trim(); // Trim whitespace for clean processing

                if (line.startsWith("if")) {
                    // Extract and evaluate the condition
                    String condition = extractCondition(line);
                    boolean conditionResult = evaluateBooleanExpression(condition); // Check if condition is true or false

                    if (conditionResult) {
                        // Execute the if block
                        lineIndex = executeBlock(lines, lineIndex + 1);
                        executionStack.push(true); // Set flag to indicate if block was executed
                    } else {
                        // Skip the if block
                        lineIndex = skipBlock(lines, lineIndex);
                        executionStack.push(false); // Clear flag indicating if block was not executed
                    }
                } else if (line.startsWith("else")) {
                    if (executionStack.isEmpty() || executionStack.pop()) {
                        // Skip the else block if the if block was executed
                        lineIndex = skipBlock(lines, lineIndex);
                    } else {
                        // Execute the else block
                        lineIndex = executeBlock(lines, lineIndex + 1);
                    }
                } else if (line.startsWith("while")) {
                    // Extract the condition
                    String condition = extractCondition(line);
                    int startOfLoop = lineIndex + 1;
                    int endOfLoop = findEndOfBlock(lines, lineIndex);

                    // Since the condition needs to be evaluated repeatedly, we need to re-evaluate it inside the loop
                    while (evaluateBooleanExpression(condition)) {
                        executeBlock(lines, startOfLoop, endOfLoop);

                        if (breakFlag) {
                            breakFlag = false; // Reset the break flag
                            break;
                        }

                        // Re-evaluate the condition after executing the block
                        condition = extractCondition(line);
                    }

                    lineIndex = endOfLoop; // Skip past the end of the while block after execution
                } else {
                    interpretLine(line); // Process non-control lines
                    lineIndex++;
                }
            }
        }

        private int skipBlock(String[] lines, int lineIndex) {
            // Skip lines until we encounter a closing brace '}'
            int openBraces = 1; // We already encountered one opening brace
            lineIndex++; // Move to the next line after the block start
            while (lineIndex < lines.length && openBraces > 0) {
                String line = lines[lineIndex].trim();
                if (line.equals("{")) {
                    openBraces++;
                } else if (line.equals("}")) {
                    openBraces--;
                }
                lineIndex++;
            }
            return lineIndex; // Return the line index after the closing brace
        }

        private int findEndOfBlock(String[] lines, int lineIndex) {
            // Find the end of the block
            int openBraces = 1;
            lineIndex++;
            while (lineIndex < lines.length && openBraces > 0) {
                String line = lines[lineIndex].trim();
                if (line.equals("{")) {
                    openBraces++;
                } else if (line.equals("}")) {
                    openBraces--;
                }
                lineIndex++;
            }
            return lineIndex - 1;
        }

        private int executeBlock(String[] lines, int start) {
            // Execute lines within a block until the closing brace
            int lineIndex = start;
            while (lineIndex < lines.length && !lines[lineIndex].trim().equals("}")) {
                interpretLine(lines[lineIndex].trim()); // Interpret the line
                if (breakFlag) {
                    breakFlag = false;
                    break;  // Exit the block on break
                }
                lineIndex++;
            }
            return lineIndex + 1; // Return the line index after the closing brace
        }

        private void executeBlock(String[] lines, int start, int end) {
            // Execute lines within a block
            for (int i = start; i < end; i++) {
                interpretLine(lines[i].trim()); // Interpret each line
                if (breakFlag) {
                    breakFlag = false;
                    break;  // Exit the block on break
                }
            }
        }

        private void interpretLine(String line) {
            // Process specific statements inside the block (like var declarations or print)
            if (line.startsWith("var ")) {
                handleVariableDeclaration(line);
            } else if (line.startsWith("boolean ")) {
                handleBooleanDeclaration(line);
            } else if (line.contains("+=") || line.contains("-=") || line.contains("*=") || line.contains("/=") || (line.contains("=") && !line.contains("=="))) {
                handleVariableAssignment(line);
            } else if (line.startsWith("println")) {
                handlePrint(line);
            } else if (line.contains("++")) {
                handleIncrement(line);
            } else if (line.contains("--")) {
                handleDecrement(line);
            } else if (line.equals("break")) {
                handleBreak();
            }
        }

        private void handleVariableDeclaration(String line) {
            line = line.replace("var ", "").trim();
            String[] parts = line.split("=");
            String variableName = parts[0].trim();
            String expression = parts[1].trim();

            // Check if the expression is a boolean value
            if (expression.equals("true") || expression.equals("false")) {
                boolean value = Boolean.parseBoolean(expression);
                booleanVariables.put(variableName, value);
            } else {
                int value = evaluateExpression(expression);
                variables.put(variableName, value);
            }
        }

        private void handleBooleanDeclaration(String line) {
            line = line.replace("boolean ", "").trim();
            String[] parts = line.split("=");
            String variableName = parts[0].trim();
            String expression = parts[1].trim();

            boolean value = evaluateBooleanExpression(expression);
            booleanVariables.put(variableName, value);
        }

        private void handleVariableAssignment(String line) {
            String[] parts;
            String variableName;
            String expression;

            if (line.contains("+=")) {
                parts = line.split("\\+=");
                variableName = parts[0].trim();
                expression = parts[1].trim();
                if (variables.containsKey(variableName)) {
                    int value = evaluateExpression(expression);
                    variables.put(variableName, variables.get(variableName) + value);
                }
            } else if (line.contains("-=")) {
                parts = line.split("-=");
                variableName = parts[0].trim();
                expression = parts[1].trim();
                if (variables.containsKey(variableName)) {
                    int value = evaluateExpression(expression);
                    variables.put(variableName, variables.get(variableName) - value);
                }
            } else if (line.contains("*=")) {
                parts = line.split("\\*=");
                variableName = parts[0].trim();
                expression = parts[1].trim();
                if (variables.containsKey(variableName)) {
                    int value = evaluateExpression(expression);
                    variables.put(variableName, variables.get(variableName) * value);
                }
            } else if (line.contains("/=")) {
                parts = line.split("/=");
                variableName = parts[0].trim();
                expression = parts[1].trim();
                if (variables.containsKey(variableName)) {
                    int value = evaluateExpression(expression);
                    if (value == 0) {
                        throw new ArithmeticException("Division by zero");
                    }
                    variables.put(variableName, variables.get(variableName) / value);
                }
            } else {
                parts = line.split("=");
                variableName = parts[0].trim();
                expression = parts[1].trim();
                if (variables.containsKey(variableName)) {
                    int value = evaluateExpression(expression);
                    variables.put(variableName, value);
                } else if (booleanVariables.containsKey(variableName)) {
                    boolean value = evaluateBooleanExpression(expression);
                    booleanVariables.put(variableName, value);
                }
            }
        }

        private void handleIncrement(String line) {
            String variableName = line.replace("++", "").trim();
            if (variables.containsKey(variableName)) {
                variables.put(variableName, variables.get(variableName) + 1);
            }
        }

        private void handleDecrement(String line) {
            String variableName = line.replace("--", "").trim();
            if (variables.containsKey(variableName)) {
                variables.put(variableName, variables.get(variableName) - 1);
            }
        }

        private void handleBreak() {
            breakFlag = true; // Set the break flag to true
        }

        private void handlePrint(String line) {
            int start = line.indexOf("(") + 1;
            int end = line.lastIndexOf(")");
            String expression = line.substring(start, end).trim();

            if (expression.startsWith("\"") && expression.endsWith("\"")) {
                // Handle string printing
                String stringValue = expression.substring(1, expression.length() - 1);
                System.out.println(stringValue);
            } else if (booleanVariables.containsKey(expression)) {
                // Handle boolean variable printing
                System.out.println(booleanVariables.get(expression));
            } else if (variables.containsKey(expression)) {
                // Handle integer variable printing
                System.out.println(variables.get(expression));
            } else {
                // Handle integer expression printing
                int value = evaluateExpression(expression);
                System.out.println(value); // Print the value
            }
        }

        private String extractCondition(String line) {
            int start = line.indexOf("(") + 1;
            int end = line.indexOf(")");
            return line.substring(start, end).trim(); // Extract the condition expression
        }

        private boolean evaluateBooleanExpression(String expression) {
            // Handle logical OR (||)
            if (expression.contains("||")) {
                String[] parts = expression.split("\\|\\|");
                for (String part : parts) {
                    if (evaluateBooleanExpression(part.trim())) {
                        return true;
                    }
                }
                return false;
            }

            // Handle logical AND (&&)
            if (expression.contains("&&")) {
                String[] parts = expression.split("&&");
                for (String part : parts) {
                    if (!evaluateBooleanExpression(part.trim())) {
                        return false;
                    }
                }
                return true;
            }

            // Handle true/false literals
            if (expression.equals("true")) {
                return true;
            }
            if (expression.equals("false")) {
                return false;
            }

            // Handle logical NOT (negation)
            if (expression.startsWith("!")) {
                String subExpression = expression.substring(1).trim();
                return !evaluateBooleanExpression(subExpression);
            }

            // Handle equality check (==)
            if (expression.contains("==")) {
                String[] parts = expression.split("==");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue == rightValue;
            }

            // Handle not-equal check (!=)
            if (expression.contains("!=")) {
                String[] parts = expression.split("!=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue != rightValue;
            }

            // Handle other operators like <, <=, >, >=
            if (expression.contains("<=")) {
                String[] parts = expression.split("<=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue <= rightValue;
            }

            if (expression.contains(">=")) {
                String[] parts = expression.split(">=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue >= rightValue;
            }

            if (expression.contains("<")) {
                String[] parts = expression.split("<");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue < rightValue;
            }

            if (expression.contains(">")) {
                String[] parts = expression.split(">");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue > rightValue;
            }

            // Handle boolean variables
            if (booleanVariables.containsKey(expression)) {
                return booleanVariables.get(expression);
            }

            // Evaluate integer expression and convert to boolean
            return evaluateExpression(expression) != 0;
        }

        private int evaluateExpression(String expression) {
            expression = expression.trim();

            // Handle logical NOT (negation)
            if (expression.startsWith("!")) {
                String subExpression = expression.substring(1).trim();
                return evaluateExpression(subExpression) == 0 ? 1 : 0; // Negate the result (0 -> 1, non-zero -> 0)
            }

            // Handle equality check (==)
            if (expression.contains("==")) {
                String[] parts = expression.split("==");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue == rightValue ? 1 : 0; // Return 1 if true, 0 if false
            }

            // Handle not-equal check (!=)
            if (expression.contains("!=")) {
                String[] parts = expression.split("!=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue != rightValue ? 1 : 0; // Return 1 if true, 0 if false
            }

            // Handle other operators like <, <=, >, >=
            if (expression.contains("<=")) {
                String[] parts = expression.split("<=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue <= rightValue ? 1 : 0;
            }

            if (expression.contains(">=")) {
                String[] parts = expression.split(">=");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue >= rightValue ? 1 : 0;
            }

            if (expression.contains("<")) {
                String[] parts = expression.split("<");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue < rightValue ? 1 : 0;
            }

            if (expression.contains(">")) {
                String[] parts = expression.split(">");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue > rightValue ? 1 : 0;
            }

            // Handle modulus operation (%)
            if (expression.contains("%")) {
                String[] parts = expression.split("%");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue % rightValue;
            }

            // Handle addition (+)
            if (expression.contains("+")) {
                String[] parts = expression.split("\\+");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue + rightValue;
            }

            // Handle subtraction (-)
            if (expression.contains("-")) {
                String[] parts = expression.split("-");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue - rightValue;
            }

            // Handle multiplication (*)
            if (expression.contains("*")) {
                String[] parts = expression.split("\\*");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                return leftValue * rightValue;
            }

            // Handle division (/)
            if (expression.contains("/")) {
                String[] parts = expression.split("/");
                int leftValue = evaluate(parts[0].trim());
                int rightValue = evaluate(parts[1].trim());
                if (rightValue == 0) {
                    throw new ArithmeticException("Division by zero");
                }
                return leftValue / rightValue;
            }

            // Replace variables in the expression
            for (Map.Entry<String, Integer> entry : variables.entrySet()) {
                expression = expression.replace(entry.getKey(), String.valueOf(entry.getValue()));
            }

            // Evaluate the expression
            return evaluate(expression);
        }

        private int evaluate(String expression) {
            // Check for variable names in the expression and replace them with their values
            expression = substituteVariables(expression);

            Stack<Integer> values = new Stack<>();
            Stack<Character> operators = new Stack<>();

            for (int i = 0; i < expression.length(); i++) {
                char c = expression.charAt(i);

                if (c == ' ') {
                    continue;
                }

                if (Character.isDigit(c)) {
                    int num = 0;
                    while (i < expression.length() && Character.isDigit(expression.charAt(i))) {
                        num = num * 10 + (expression.charAt(i) - '0');
                        i++;
                    }
                    i--;
                    values.push(num);
                } else if (c == '(') {
                    operators.push(c);
                } else if (c == ')') {
                    while (!operators.isEmpty() && operators.peek() != '(') {
                        values.push(applyOperator(operators.pop(), values.pop(), values.pop()));
                    }
                    operators.pop();
                } else if (isOperator(c)) {
                    while (!operators.isEmpty() && precedence(operators.peek()) >= precedence(c)) {
                        values.push(applyOperator(operators.pop(), values.pop(), values.pop()));
                    }
                    operators.push(c);
                }
            }

            while (!operators.isEmpty()) {
                values.push(applyOperator(operators.pop(), values.pop(), values.pop()));
            }

            return values.isEmpty() ? 0 : values.pop();  // Return 0 if the stack is empty
        }

        private String substituteVariables(String expression) {
            // Replace variables in the expression with their actual values
            for (Map.Entry<String, Integer> entry : variables.entrySet()) {
                expression = expression.replace(entry.getKey(), String.valueOf(entry.getValue()));
            }
            return expression;
        }

        private boolean isOperator(char c) {
            return c == '+' || c == '-' || c == '*' || c == '/' || c == '%';
        }

        private int precedence(char operator) {
            switch (operator) {
                case '+':
                case '-':
                    return 1;
                case '*':
                case '/':
                case '%':
                    return 2;
                default:
                    return -1;
            }
        }

        private int applyOperator(char operator, int b, int a) {
            switch (operator) {
                case '+':
                    return a + b;
                case '-':
                    return a - b;
                case '*':
                    return a * b;
                case '/':
                    if (b == 0) throw new ArithmeticException("Division by zero");
                    return a / b;
                case '%':
                    return a % b;
            }
            return 0;
        }

        public static void main(String[] args) {
            // Example code to test the interpreter
            String code = """
         var x=5
         var y=10
         var z = 15
         while(x<10 && y>5){
         
        if(z<15){
        
        println("not working")
        
        }
        
        x++
        y--
        println(x)
        println(y)
    
         
        }
                  
        """;

            KotlinToJavaInterpreter interpreter = new KotlinToJavaInterpreter();
            interpreter.interpret(code);
        }
    }
